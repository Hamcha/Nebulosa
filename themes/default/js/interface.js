// Generated by CoffeeScript 1.6.3
(function() {
  var InterfaceViewModel;

  InterfaceViewModel = function() {
    var self;
    self = this;
    self.networks = ko.observableArray([]);
    self.currentNetwork = ko.observable("");
    self.currentChannel = ko.observable("");
    self.messageBar = ko.observable("");
    self.userlist = ko.observable({});
    self.messages = ko.observable({});
    self.isChannel = true;
    self.bufferMode = false;
    self.channelUsers = ko.computed(function() {
      return self.userlist()[self.currentNetwork() + self.currentChannel()];
    });
    self.channelActivity = ko.computed(function() {
      return self.messages()[self.currentNetwork() + self.currentChannel()];
    });
    self.currentTopic = ko.computed(function() {
      var chan, curchan, curnet, net, nets, tnick, topic;
      nets = self.networks();
      curnet = self.currentNetwork();
      curchan = self.currentChannel();
      if (!(self.isChannel && nets !== [] && curnet !== "" && curchan !== "")) {
        return false;
      }
      net = filterSingle(nets, function(x) {
        return x.id === curnet;
      });
      chan = filterSingle(nets[net.id].chans, function(x) {
        return x.key === curchan;
      });
      topic = nets[net.id].chans[chan.id].topic;
      tnick = nets[net.id].chans[chan.id].topicBy;
      if (topic != null) {
        return {
          topic: topic,
          topicBy: tnick
        };
      } else {
        return false;
      }
    });
    self.currentNickname = ko.computed(function() {
      var curnet, nets;
      curnet = self.currentNetwork();
      nets = filterSingle(self.networks(), function(x) {
        return x.id === curnet;
      });
      if (nets != null) {
        return nets.elem.nickname;
      } else {
        return null;
      }
    });
    self.netNickname = function(network) {
      var curnet, nets;
      curnet = self.currentNetwork();
      nets = filterSingle(self.networks(), function(x) {
        return x.id === network;
      });
      if (nets != null) {
        return nets.elem.nickname;
      } else {
        return null;
      }
    };
    self.addMessage = function(data) {
      var m, msgs, omitnick;
      msgs = self.messages();
      if (msgs[data.network + data.channel] == null) {
        msgs[data.network + data.channel] = [];
      }
      m = msgs[data.network + data.channel];
      if (m[m.length - 1] != null) {
        if (m[m.length - 1].user === data.nickname) {
          omitnick = true;
        }
      }
      msgs[data.network + data.channel].push({
        type: "message",
        shownick: omitnick == null,
        user: data.nickname,
        message: data.message,
        timestamp: formatTime(data.time)
      });
      self.messages(msgs);
      return scrollBottom();
    };
    self.addNotice = function(data) {
      var curchan, curnet, msgs;
      curchan = self.currentChannel();
      curnet = self.currentNetwork();
      msgs = self.messages();
      if (msgs[curnet + curchan] == null) {
        msgs[curnet + curchan] = [];
      }
      msgs[curnet + curchan].push({
        type: "notice",
        channel: data.channel,
        user: data.nickname,
        message: data.message,
        timestamp: formatTime(data.time)
      });
      self.messages(msgs);
      return scrollBottom();
    };
    self.addChannelAction = function(type, data) {
      var chan, indexChan, indexUser, msgs, net, nets, ulist;
      msgs = self.messages();
      if (msgs[data.network + data.channel] == null) {
        msgs[data.network + data.channel] = [];
      }
      switch (type) {
        case "join":
          if (data.nickname === self.netNickname(data.network)) {
            interop.socket.emit("chaninfo", {
              network: data.network,
              channel: data.channel
            });
            return;
          }
          msgs[data.network + data.channel].push({
            type: "chaction",
            message: data.nickname + " has joined the channel.",
            timestamp: formatTime(data.time)
          });
          if (self.bufferMode) {
            break;
          }
          ulist = self.userlist();
          ulist[data.network + data.channel].push(data.nickname);
          self.userlist(ulist);
          break;
        case "part":
          if (data.nickname === self.netNickname(data.network)) {
            self.switchTo(data.network, ":status", false);
            nets = self.networks();
            net = filterSingle(nets, function(x) {
              return x.id === data.network;
            });
            chan = filterSingle(nets[net.id].chans, function(x) {
              return x.key === data.channel;
            });
            nets[net.id].chans.splice(chan, 1);
            self.networks(nets);
            return;
          }
          msgs[data.network + data.channel].push({
            type: "chaction",
            message: data.nickname + " has left the channel.",
            timestamp: formatTime(data.time)
          });
          if (self.bufferMode) {
            break;
          }
          ulist = self.userlist();
          indexChan = data.network + data.channel;
          indexUser = ulist[indexChan].indexOf(data.nickname);
          if (indexUser > 0) {
            ulist[indexChan].splice(ulist[indexChan].indexOf(data.nickname), 1);
          }
          self.userlist(ulist);
      }
      self.messages(msgs);
      return scrollBottom();
    };
    self.addError = function(message) {
      var curchan, curnet, msgs;
      curchan = self.currentChannel();
      curnet = self.currentNetwork();
      msgs = self.messages();
      if (msgs[curnet + curchan] == null) {
        msgs[curnet + curchan] = [];
      }
      msgs[curnet + curchan].push({
        type: "error",
        user: "",
        message: message
      });
      self.messages(msgs);
      return scrollBottom();
    };
    self.sendMessage = function() {
      var action, curnick, message, parts, tochn, tonet;
      tonet = self.currentNetwork();
      tochn = self.currentChannel();
      curnick = self.currentNickname();
      message = self.messageBar();
      if (message[0] === "/" && (message[1] != null) && message[1] !== "/") {
        parts = message.substring(1).split(" ");
        action = parts.splice(0, 1);
        if (interop.command[action] == null) {
          self.addError("Unsupported command (" + action + ")");
        } else {
          interop.command[action](tonet, tochn, curnick, parts);
        }
      } else {
        message = message.replace(/^\/\//, "/");
        interop.socket.emit("message", {
          network: tonet,
          channel: tochn,
          message: message,
          nickname: curnick
        });
        self.addMessage({
          network: tonet,
          nickname: self.currentNickname(),
          channel: tochn,
          message: message,
          time: +(new Date)
        });
      }
      return self.messageBar("");
    };
    self.switchTo = function(network, channel, isChannel) {
      self.isChannel = isChannel;
      self.currentNetwork(network);
      return self.currentChannel(channel);
    };
    self.updateChannelInfo = function(data) {
      var chan, net, nets;
      nets = self.networks();
      net = filterSingle(self.networks(), function(x) {
        return x.id === data.network;
      });
      chan = filterSingle(nets[net.id].chans, function(x) {
        return x.key === data.channeldata.key;
      });
      self.updateChannelUsers({
        network: data.network,
        channel: data.channeldata.key,
        nicks: data.channeldata.users
      });
      if (chan != null) {
        nets[net.id].chans[chan.id] = data.channeldata;
      } else {
        nets[net.id].chans.push(data.channeldata);
      }
      return self.networks(nets);
    };
    self.updateChannelUsers = function(data) {
      var indexChan, uchan, ulist, uname, uval, _ref;
      indexChan = data.network + data.channel;
      ulist = self.userlist();
      uchan = [];
      _ref = data.nicks;
      for (uname in _ref) {
        uval = _ref[uname];
        uchan.push(uname);
      }
      ulist[indexChan] = uchan;
      return self.userlist(ulist);
    };
    self.setTopic = function(data) {
      var chan, msgs, net, nets;
      nets = self.networks();
      net = filterSingle(nets, function(x) {
        return x.id === data.network;
      });
      chan = filterSingle(nets[net.id].chans, function(x) {
        return x.key === data.channel;
      });
      nets[net.id].chans[chan.id].topic = data.topic;
      nets[net.id].chans[chan.id].topicBy = data.nickname;
      self.networks(nets);
      msgs = self.messages();
      if (msgs[data.network + data.channel] == null) {
        msgs[data.network + data.channel] = [];
      }
      msgs[data.network + data.channel].push({
        type: "chaction",
        message: data.nickname + " has set the topic to: " + data.topic,
        timestamp: formatTime(data.time)
      });
      self.messages(msgs);
      return scrollBottom();
    };
    self.initNetworks = function(data) {
      var cname, cval, network, nid, tdata, tnet, uchan, udata, uname, uval, _ref, _ref1;
      tdata = [];
      udata = {};
      for (nid in data) {
        network = data[nid];
        tnet = {};
        tnet.nickname = network.nickname;
        tnet.name = network.name;
        tnet.id = nid;
        tnet.chans = [];
        _ref = network.chans;
        for (cname in _ref) {
          cval = _ref[cname];
          cval.id = cname;
          tnet.chans.push(cval);
          uchan = [];
          _ref1 = cval.users;
          for (uname in _ref1) {
            uval = _ref1[uname];
            uchan.push(uname);
          }
          udata[tnet.id + cname] = uchan;
        }
        tdata.push(tnet);
      }
      self.networks(tdata);
      self.userlist(udata);
      if (tdata[0] != null) {
        self.currentNetwork(tdata[0].id);
      }
      if (tdata[0].chans[0] != null) {
        self.currentChannel(tdata[0].chans[0].key);
      }
    };
  };

  window["interface"] = new InterfaceViewModel();

  $(document).ready(function() {
    return ko.applyBindings(window["interface"]);
  });

}).call(this);
