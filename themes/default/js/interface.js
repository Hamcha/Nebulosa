// Generated by CoffeeScript 1.6.3
(function() {
  var Channel, InterfaceViewModel, User, lastIndex, wordComplete;

  Channel = function(cdata) {
    this.created = cdata.created;
    this.key = cdata.key;
    this.isquery = false;
    this.unread = ko.observable(0);
    this.serverName = cdata.serverName;
    this.mode = ko.observable(cdata.mode);
    if (cdata.topic != null) {
      this.topic = cdata.topic;
    }
    if (cdata.topicBy != null) {
      this.topicBy = cdata.topicBy;
    }
  };

  User = function(nick, val) {
    this.nick = ko.observable(nick);
    this.val = ko.observable(val);
  };

  InterfaceViewModel = function() {
    var self;
    self = this;
    self.networks = ko.observable({});
    self.currentNetwork = ko.observable("");
    self.currentChannel = ko.observable("");
    self.messageBar = ko.observable("");
    self.userlist = ko.observable({});
    self.messages = ko.observable({});
    self.isChannel = true;
    self.bufferMode = false;
    self.networkList = ko.computed(function() {
      var cname, cval, network, nid, tdata, tnet, uchan, udata, uname, uval, _ref, _ref1, _ref2;
      tdata = [];
      udata = {};
      _ref = self.networks();
      for (nid in _ref) {
        network = _ref[nid];
        tnet = {};
        tnet.nickname = network.nickname;
        tnet.name = network.name;
        tnet.id = nid;
        tnet.chans = [];
        _ref1 = network.chans;
        for (cname in _ref1) {
          cval = _ref1[cname];
          cval.id = cname;
          cval.unread();
          tnet.chans.push(cval);
          uchan = [];
          _ref2 = cval.users;
          for (uname in _ref2) {
            uval = _ref2[uname];
            uchan.push(uname);
          }
          udata[tnet.id + cname] = uchan;
        }
        tdata.push(tnet);
      }
      return tdata;
    });
    self.channelUsers = ko.computed(function() {
      var ulist;
      ulist = self.userlist()[self.currentNetwork() + "." + self.currentChannel()];
      if (ulist == null) {
        return;
      }
      ulist.sort(self.nickSort);
      return ulist;
    });
    self.channelActivity = ko.computed(function() {
      return self.messages()[self.currentNetwork() + "." + self.currentChannel()].slice(-50);
    });
    self.currentTopic = ko.computed(function() {
      var curchan, curnet, nets, tnick, topic;
      nets = self.networks();
      curnet = self.currentNetwork();
      curchan = self.currentChannel();
      if (!(self.isChannel && nets !== [] && curnet !== "" && curchan !== "" && (nets[curnet].chans[curchan] != null))) {
        return false;
      }
      topic = nets[curnet].chans[curchan].topic;
      tnick = nets[curnet].chans[curchan].topicBy;
      if (topic != null) {
        return {
          topic: topic,
          topicBy: tnick
        };
      } else {
        return false;
      }
    });
    self.currentNickname = ko.computed(function() {
      var curnet, nets;
      curnet = self.currentNetwork();
      nets = self.networks()[curnet];
      if (nets != null) {
        return nets.nickname;
      } else {
        return null;
      }
    });
    self.netNickname = function(network) {
      var curnet, nets;
      curnet = self.currentNetwork();
      nets = self.networks()[curnet];
      if (nets != null) {
        return nets.nickname;
      } else {
        return null;
      }
    };
    self.addMessage = function(data) {
      var m, msgs, nets, omitnick;
      msgs = self.messages();
      nets = self.networks();
      if (data.channel === self.netNickname(data.network)) {
        if ((nets[data.network].chans[data.nickname] == null) && !self.bufferMode) {
          nets[data.network].chans[data.nickname] = new Channel({
            key: data.nickname,
            id: data.nickname
          });
          nets[data.network].chans[data.nickname].isquery = true;
          self.networks(nets);
        }
        data.channel = data.nickname;
      }
      if (msgs[data.network + "." + data.channel] == null) {
        msgs[data.network + "." + data.channel] = [];
      }
      m = msgs[data.network + "." + data.channel];
      if (m[m.length - 1] != null) {
        if (m[m.length - 1].user === data.nickname) {
          omitnick = true;
        }
      }
      msgs[data.network + "." + data.channel].push({
        type: "message",
        shownick: omitnick == null,
        user: data.nickname,
        message: self.processMessage(data.message),
        timestamp: formatTime(data.time)
      });
      self.networks(nets);
      self.messages(msgs);
      if (self.bufferMode) {
        return;
      }
      if (data.network !== self.currentNetwork() || data.channel !== self.currentChannel()) {
        return nets[data.network].chans[data.channel].unread(nets[data.network].chans[data.channel].unread() + 1);
      } else {
        return scrollBottom();
      }
    };
    self.addNotice = function(data) {
      var curchan, curnet, msgs;
      curchan = self.currentChannel();
      curnet = self.currentNetwork();
      msgs = self.messages();
      if (msgs[curnet + "." + curchan] == null) {
        msgs[curnet + "." + curchan] = [];
      }
      msgs[curnet + "." + curchan].push({
        type: "notice",
        channel: data.channel,
        user: data.nickname,
        message: self.processMessage(data.message),
        timestamp: formatTime(data.time)
      });
      self.messages(msgs);
      return scrollBottom();
    };
    self.addChannelAction = function(type, data) {
      var chan, channels, indexChan, indexUser, msgs, nets, reason, ulist, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2;
      msgs = self.messages();
      switch (type) {
        case "join":
          if (!self.bufferMode && data.nickname === self.netNickname(data.network)) {
            interop.socket.emit("chaninfo", {
              network: data.network,
              channel: data.channel
            });
            return;
          }
          if (msgs[data.network + "." + data.channel] == null) {
            msgs[data.network + "." + data.channel] = [];
          }
          msgs[data.network + "." + data.channel].push({
            type: "chaction",
            message: "<b>" + data.nickname + "</b>  has joined the channel",
            timestamp: formatTime(data.time)
          });
          if (self.bufferMode) {
            break;
          }
          ulist = self.userlist();
          ulist[data.network + "." + data.channel].push(new User(data.nickname, ""));
          self.userlist(ulist);
          break;
        case "part":
        case "kick":
        case "quit":
          if (!self.bufferMode && data.nickname === self.netNickname(data.network)) {
            self.switchTo(data.network, ":status", false);
            nets = self.networks();
            delete nets[data.network].chans[data.channel];
            self.networks(nets);
            return;
          }
          data.reason = ifval(data.reason, "");
          switch (type) {
            case "part":
              if (msgs[data.network + "." + data.channel] == null) {
                msgs[data.network + "." + data.channel] = [];
              }
              msgs[data.network + "." + data.channel].push({
                type: "chaction",
                message: "<b>" + data.nickname + "</b>  has left the channel (" + data.reason + ")",
                timestamp: formatTime(data.time)
              });
              break;
            case "kick":
              if (msgs[data.network + "." + data.channel] == null) {
                msgs[data.network + "." + data.channel] = [];
              }
              msgs[data.network + "." + data.channel].push({
                type: "chaction",
                message: "<b>" + data.nickname + "</b>  has been kicked by <b>" + data.by + "</b> (" + data.reason + ")",
                timestamp: formatTime(data.time)
              });
              break;
            case "quit":
              if (!Array.isArray(data.channels)) {
                data.channels = [data.channels];
              }
              reason = ifval(data.reason, "");
              _ref = data.channels;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                chan = _ref[_i];
                if (msgs[data.network + "." + chan] == null) {
                  msgs[data.network + "." + chan] = [];
                }
                msgs[data.network + "." + chan].push({
                  type: "chaction",
                  message: "<b>" + data.nickname + "</b> has quit (" + reason + ")",
                  timestamp: formatTime(data.time)
                });
              }
          }
          if (self.bufferMode) {
            break;
          }
          ulist = self.userlist();
          if (type !== "quit") {
            channels = [data.channel];
          } else {
            channels = data.channels;
          }
          for (_j = 0, _len1 = channels.length; _j < _len1; _j++) {
            chan = channels[_j];
            indexChan = data.network + "." + chan;
            indexUser = filterSingle(ulist[indexChan], function(x) {
              return x.nick === data.nickname;
            });
            if (indexUser > 0) {
              ulist[indexChan].splice(indexUser, 1);
            }
            self.userlist(ulist);
          }
          break;
        case "mode":
          data.argument = ifval(data.argument, "");
          data.by = ifval(data.by, data.network);
          if (msgs[data.network + "." + data.channel] == null) {
            msgs[data.network + "." + data.channel] = [];
          }
          msgs[data.network + "." + data.channel].push({
            type: "chaction",
            message: "<b>" + data.by + "</b>  sets mode " + data.what + data.mode + " " + data.argument,
            timestamp: formatTime(data.time)
          });
          break;
        case "nick":
          if (!self.bufferMode && data.oldnick === self.netNickname(data.network)) {
            nets = self.networks();
            nets[data.network].nickname = data.newnick;
            self.networks(nets);
          }
          if (!Array.isArray(data.channels)) {
            data.channels = [data.channels];
          }
          _ref1 = data.channels;
          for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
            chan = _ref1[_k];
            if (msgs[data.network + "." + chan] == null) {
              msgs[data.network + "." + chan] = [];
            }
            msgs[data.network + "." + chan].push({
              type: "chaction",
              message: "<b>" + data.oldnick + "</b> is now <b>" + data.newnick + "</b>",
              timestamp: formatTime(data.time)
            });
          }
          if (self.bufferMode) {
            break;
          }
          ulist = self.userlist();
          _ref2 = data.channels;
          for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
            chan = _ref2[_l];
            indexChan = data.network + "." + chan;
            indexUser = filterSingle(ulist[indexChan], function(x) {
              return x.nick() === data.oldnick;
            });
            if (indexUser.id >= 0) {
              ulist[indexChan][indexUser.id].nick(data.newnick);
            }
          }
          self.userlist(ulist);
          break;
        case "quit":
          self.switchTo(data.network, ":status", false);
          msgs[data.network + ".:status"].push({
            type: "chaction",
            message: "Disconnected from <b>" + data.network + "</b>",
            timestamp: formatTime(data.time)
          });
      }
      self.messages(msgs);
      return scrollBottom();
    };
    self.addError = function(message) {
      var curchan, curnet, msgs;
      curchan = self.currentChannel();
      curnet = self.currentNetwork();
      msgs = self.messages();
      if (msgs[curnet + "." + curchan] == null) {
        msgs[curnet + "." + curchan] = [];
      }
      msgs[curnet + "." + curchan].push({
        type: "error",
        user: "",
        message: message
      });
      self.messages(msgs);
      return scrollBottom();
    };
    self.addWhois = function(data) {
      var curchan, curnet, msgs, ninfo;
      curchan = self.currentChannel();
      curnet = self.currentNetwork();
      msgs = self.messages();
      if (msgs[curnet + "." + curchan] == null) {
        msgs[curnet + "." + curchan] = [];
      }
      ninfo = ["<b>" + data.info.nick + "</b> is " + data.info.realname + " (" + data.info.user + "@" + data.info.host + ")", "&nbsp;&nbsp;&nbsp;&nbsp;is on <b>" + (data.info.channels.join(", ")) + "</b>", "&nbsp;&nbsp;&nbsp;&nbsp;is on " + data.info.server + " (" + data.info.serverinfo + ")"];
      if (data.info.idle != null) {
        ninfo.push("&nbsp;&nbsp;&nbsp;&nbsp;has been idle " + toTimeStr(data.info.idle));
      }
      msgs[curnet + "." + curchan].push({
        type: "whois",
        user: "",
        nickname: data.info.nick,
        info: ninfo
      });
      self.messages(msgs);
      return scrollBottom();
    };
    self.processMessage = function(message) {
      message = htmlEntities(message);
      message = linkify(message);
      return message;
    };
    self.sendMessage = function() {
      var action, curnick, message, parts, tochn, tonet;
      tonet = self.currentNetwork();
      tochn = self.currentChannel();
      curnick = self.currentNickname();
      message = self.messageBar();
      if (message[0] === "/" && (message[1] != null) && message[1] !== "/") {
        parts = message.substring(1).split(" ");
        action = parts.splice(0, 1);
        if (interop.command[action] == null) {
          self.addError("Unsupported command (" + action + ")");
        } else {
          interop.command[action](tonet, tochn, curnick, parts);
        }
      } else {
        message = message.replace(/^\/\//, "/");
        if (message === "") {
          return;
        }
        interop.socket.emit("message", {
          network: tonet,
          channel: tochn,
          message: message,
          nickname: curnick
        });
        self.addMessage({
          network: tonet,
          nickname: self.currentNickname(),
          channel: tochn,
          message: message,
          time: +(new Date)
        });
      }
      return self.messageBar("");
    };
    self.switchTo = function(network, channel, isChannel) {
      var nets;
      if (self.isChannel !== isChannel) {
        if (isChannel) {
          $("#rightbar").removeClass("hiddenbar");
          $("#centerbar").removeClass("superwide");
          $("#centerbar").addClass("normalwide");
        } else {
          $("#rightbar").addClass("hiddenbar");
          $("#centerbar").removeClass("normalwide");
          $("#centerbar").addClass("superwide");
        }
        self.isChannel = isChannel;
      }
      self.currentNetwork(network);
      self.currentChannel(channel);
      scrollBottom();
      nets = self.networks();
      nets[network].chans[channel].unread(0);
      return self.networks(nets);
    };
    self.updateChannelInfo = function(data) {
      var nets;
      nets = self.networks();
      self.updateChannelUsers({
        network: data.network,
        channel: data.channeldata.key,
        nicks: data.channeldata.users
      });
      nets[data.network].chans[data.channeldata.key] = new Channel(data.channeldata);
      self.networks(nets);
      self.currentNetwork(data.network);
      return self.currentChannel(data.channeldata.key);
    };
    self.updateChannelUsers = function(data) {
      var indexChan, uchan, ulist, uname, uval, _ref;
      indexChan = data.network + "." + data.channel;
      ulist = self.userlist();
      uchan = [];
      _ref = data.nicks;
      for (uname in _ref) {
        uval = _ref[uname];
        uchan.push(new User(uname, uval));
      }
      ulist[indexChan] = uchan;
      return self.userlist(ulist);
    };
    self.setTopic = function(data) {
      var msgs, nets;
      nets = self.networks();
      if (nets[data.network].chans[data.channel] == null) {
        return;
      }
      nets[data.network].chans[data.channel].topic = data.topic;
      nets[data.network].chans[data.channel].topicBy = data.nickname;
      self.networks(nets);
      msgs = self.messages();
      if (msgs[data.network + "." + data.channel] == null) {
        msgs[data.network + "." + data.channel] = [];
      }
      msgs[data.network + "." + data.channel].push({
        type: "chaction",
        message: data.nickname + " has set the topic to: " + data.topic,
        timestamp: formatTime(data.time)
      });
      self.messages(msgs);
      return scrollBottom();
    };
    self.initNetworks = function(data) {
      var chan, chanobjs, cid, cname, cval, nets, network, nid, _ref, _ref1;
      for (nid in data) {
        network = data[nid];
        _ref = network.chans;
        for (cname in _ref) {
          cval = _ref[cname];
          self.updateChannelUsers({
            network: nid,
            channel: cname,
            nicks: cval.users
          });
        }
        chanobjs = {};
        _ref1 = data[nid].chans;
        for (cid in _ref1) {
          chan = _ref1[cid];
          chanobjs[cid] = new Channel(chan);
        }
        data[nid].chans = chanobjs;
      }
      self.networks(data);
      nets = self.networkList();
      if (nets[0] != null) {
        self.currentNetwork(nets[0].id);
      }
      if (nets[0].chans[0] != null) {
        self.currentChannel(nets[0].chans[0].key);
      }
    };
    self.nickSort = function(a, b) {
      var vals;
      vals = "+%@&~";
      if (a.val() === "" && b.val() !== "") {
        return 1;
      }
      if (b.val() === "" && a.val() !== "") {
        return -1;
      }
      if (b.val() !== a.val()) {
        if (vals.indexOf(b.val()) > vals.indexOf(a.val())) {
          return 1;
        }
        if (vals.indexOf(b.val()) < vals.indexOf(a.val())) {
          return -1;
        }
      }
      if (b.nick() < a.nick()) {
        return 1;
      }
      if (b.nick() > a.nick()) {
        return -1;
      }
      return 0;
    };
    self.AuthError = function() {
      var modal;
      modal = new $.UIkit.modal.Modal("#autherr");
      return modal.show();
    };
    self.Exception = function(data, fatal) {
      var modal;
      if (fatal == null) {
        fatal = false;
      }
      $("#generrcnt").html("<h2>Oops..</h2><p>" + data + "</p>");
      modal = new $.UIkit.modal.Modal("#generr");
      if (fatal) {
        modal.options.bgclose = modal.options.keyboard = false;
      }
      return modal.show();
    };
    self.AuthDialog = function() {
      if (self.authdialog == null) {
        self.authdialog = new $.UIkit.modal.Modal("#authdlg");
      }
      self.authdialog.options.bgclose = self.authdialog.options.keyboard = false;
      self.authdialog.show();
      return $("#userauth").focus();
    };
    self.auth = function(formdata) {
      formdata.username.className = formdata.username.value === "" ? "uk-form-danger" : "";
      formdata.password.className = formdata.password.value === "" ? "uk-form-danger" : "";
      if (formdata.password.value === "" || formdata.username.value === "") {
        return;
      }
      self.authdialog.hide();
      return interop.createSocket(formdata.username.value, formdata.password.value);
    };
  };

  window["interface"] = new InterfaceViewModel();

  wordComplete = null;

  lastIndex = 0;

  $(document).ready(function() {
    ko.applyBindings(window["interface"]);
    $.get("/useAuth", function(data) {
      if (data === "true") {
        return window["interface"].AuthDialog();
      } else {
        return interop.createSocket();
      }
    });
    $("#autherr").on('uk.modal.hide', function() {
      return location.reload();
    });
    return $("#inputbarcont").on("keydown", '#inputbar', function(e) {
      var keyCode, users, words;
      keyCode = e.keyCode || e.which;
      if (keyCode === 9) {
        words = window["interface"].messageBar().split(" ");
        if (window["interface"].isChannel) {
          if (wordComplete === null) {
            wordComplete = words[words.length - 1];
          }
          users = window["interface"].channelUsers().filter(function(elem) {
            return elem.nick().toLowerCase().indexOf(wordComplete.toLowerCase()) === 0;
          });
          if (lastIndex >= users.length) {
            lastIndex = 0;
          }
          words[words.length - 1] = users[lastIndex].nick();
          lastIndex++;
        } else {
          words[words.length - 1] = window["interface"].currentChannel();
        }
        window["interface"].messageBar(words.join(" "));
        return e.preventDefault();
      } else {
        if (wordComplete !== null) {
          return wordComplete = null;
        }
      }
    });
  });

}).call(this);
